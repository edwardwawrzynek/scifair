;user defined types
(defstruct person (
  (name string)
  (age int)
  (parent (struct person))))
; user defined type literals
(setq (a (array (struct person))) (struct person ((name "hello") (age 0) (parent null))))
(setq (var (array int)) (array int (0 1 2 3)))
; Variable definition
(setq (var int) 1)
; Assignment
(= var (+ var 1))
; Function calls 
(func arg1 arg2 arg3)
(+ arg1 arg2)
; Conditionals
(cond
  ((== var 1) ((print "var is 1")))
  ((== var 2) ((print "var is 2")))
  (true ((print "var is not 1 or 2"))))
; Conditionals (alternate forms)
; ast->src conversion: use this form if a single conditional with a body of one expression is present
(cond
  ((== var 1) ((print "var is 1"))))
; ast->src conversion: use this form if a conditonal is a negation
(cond
  ((! (> var 5)) (
    (print "var <= 5")
    (print "cool"))))
; ast->src conversion: use this form if a conditional chain with at least two equality checks on the same variable is present
(cond
  ((== var 1) ((print "var is 1")))
  ((== var 2) ((print "var is 2")))
  (true ((print "var is not 1 or 2"))))
; Function expressions
(lambda int ((a int) (b int))
  (print "test func")
  (return (+ a b)))
; Named functions
(defun sum int ((a int) (b int))
  (print "test func")
  (return (+ a b)))
; functions (alternate form)
;ast->src conversion: use these forms if single expression body is present
; if we have type inference, specifying return type will be unnessesary
(lambda int ((a int) (b int))
  (return (+ a b)))
(defun sum int ((a int) (b int))
  (return (+ a b)))
; Loops (note: this would be converted to a range automatically)
(for (setq (i int) 0) (< i 5) (++ i) (
  (print i)))
; Loops alternate forms
;ast->src conversion: use this form for a for loop with a starting assignment, less than check, and increment by one
; this form could easily support type inference
;range i: int in 0..5 {
;}
(setq (people (array (struct person))) (array (struct person) ((struct person ((name "p1") (age 1) (parent null))) (struct person ((name "p2") (age 2) (parent null))))))
; foreach form (type inference could be easily supported):
;foreach p: person, index: int in people {
;  printnum index
;  print p.name
;}
; the above loop would be matched to this form
;for index: int = 0, i < people.length, i++ {
;  p = people[i]
;  printnum index
;  print p.name
;}
; potentially also match this form (inline array index)
;for index: int = 0, i < people.length, i++ {
;  printnum index
;  print people[i].name
;}
; map espression
;names: []string = map elem: person, i: int in people => elem.name
; many loops could be pattern matched to a map, but we should at least support this form:
;names: []string = []
;foreach elem: person, i: int in people {
;  names.push(elem.name)
;}
